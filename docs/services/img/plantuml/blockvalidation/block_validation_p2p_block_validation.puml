@startuml
queue "blockFoundCh\nBlock Found Channel" as BFC
participant "Block Validation Server\n(Server.go)" as BVS
entity "Block Validation\n(BlockValidation.go)" as BVVB
participant "Util HTTP\nRequest" as Util
queue "catchupCh\nCatchup Channel" as CCC
entity "Block" as Block
database "Subtree Store" as SubtreeStore
database "UTXO Store" as UTXOStore
database "Tx Store" as TxStore
participant "Blockchain\nService" as BC
participant "Subtree Validation\nService" as SVS

BFC -> BVS: processBlockFound(ctx, hash, baseURL)
activate BVS

BVS -> BC: GetBlockExists(ctx, hash)
activate BC
BC --> BVS: exists / not exists
deactivate BC

alt Not Exists - Start the Validation process
    BVS -> Util: DoHTTPRequest(ctx, URL)
    activate Util
    Util --> BVS: block data
    deactivate Util

    BVS -> BC: GetBlockExists(ctx, block.Header.HashPrevBlock)
    activate BC
    BC --> BVS: parent exists / not exists
    deactivate BC

    alt Parent Not Exists - Kick off the catch up process
        BVS -> CCC: catchupCh <- processBlockCatchup{block, baseURL}
    end

    alt Parent Exists - Proceed with the Validation

    BVS -> BVVB: ValidateBlock(ctx, block, baseURL)
    activate BVVB
    BVVB -> BVVB: validateBlockSubtrees(ctx, block, baseUrl)
    activate BVVB

    loop For each Subtree
       BVVB -> SubtreeStore: Exists(ctx, subtreeHash)
       activate SubtreeStore
       SubtreeStore --> BVVB: exists / not exists
       deactivate SubtreeStore

        alt Subtree Not Exists
           BVVB -> SVS: CheckSubtree(ctx, subtreeHash, baseURL)
           activate SVS
           SVS --> BVVB
           deactivate SVS
        end
    end

    deactivate BVVB

    BVVB -> BC: GetBlockHeaders(ctx, block.Header.HashPrevBlock, 100)
    activate BC
    BC --> BVVB: block headers
    deactivate BC

    BVVB -> BVVB: storeCoinbaseTx(ctx, block)
    activate BVVB
    BVVB -> UTXOStore: Create(ctx, block.CoinbaseTx)
    activate UTXOStore
    UTXOStore -> BVVB
    deactivate UTXOStore
    deactivate BVVB


    BVVB -> Block: Valid(ctx, subtreeStore, UTXOStore, blockHeaders)
    activate Block
    Block --> BVVB
    deactivate Block


    BVVB -> BC: AddBlock(ctx, block, baseURL)
    activate BC
    BC --> BVVB
    deactivate BC

    BVVB -> TxStore: Set(ctx, block.CoinbaseTx.TxIDChainHash()[:], block.CoinbaseTx.Bytes())
    activate TxStore
    TxStore --> BVVB
    deactivate TxStore



    BVVB -> BVVB: finalizeBlockValidation(ctx, block)
    activate BVVB
    BVVB -> Block: GetSubtrees(subtreeStore)
    activate Block
    loop For each subtree hash in the block
        Block -> SubtreeStore: Get(gCtx, subtreeHash[:])
        activate SubtreeStore
        SubtreeStore -> Block: subtree
        deactivate SubtreeStore
    end
    Block -> BVVB
    deactivate Block


    BVVB -> BVVB: updateSubtreesTTL(ctx, block)
    activate BVVB
    loop For each Subtree in the Block
        BVVB -> SubtreeStore: SetTTL(ctx, subtreeHash, 0)
        activate SubtreeStore
        SubtreeStore --> BVVB: TTL set to 0 for the subtree
        deactivate SubtreeStore
    end
    BVVB -> BC: SetBlockSubtreesSet(ctx, block.Header.Hash())
    activate BC
    BC --> BVVB
    deactivate BC
    deactivate BVVB

    deactivate BVVB

    alt If Error
    BVVB  -> BC: InvalidateBlock(ctx, block.Header.Hash())
    end
    deactivate BVVB
    end

end

deactivate BVS

left footer Last Modified On: 3-July-2024

@enduml
