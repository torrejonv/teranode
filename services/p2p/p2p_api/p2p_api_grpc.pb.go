// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: services/p2p/p2p_api/p2p_api.proto

package p2p_api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PeerService_GetPeers_FullMethodName                = "/p2p_api.PeerService/GetPeers"
	PeerService_BanPeer_FullMethodName                 = "/p2p_api.PeerService/BanPeer"
	PeerService_UnbanPeer_FullMethodName               = "/p2p_api.PeerService/UnbanPeer"
	PeerService_IsBanned_FullMethodName                = "/p2p_api.PeerService/IsBanned"
	PeerService_ListBanned_FullMethodName              = "/p2p_api.PeerService/ListBanned"
	PeerService_ClearBanned_FullMethodName             = "/p2p_api.PeerService/ClearBanned"
	PeerService_AddBanScore_FullMethodName             = "/p2p_api.PeerService/AddBanScore"
	PeerService_ConnectPeer_FullMethodName             = "/p2p_api.PeerService/ConnectPeer"
	PeerService_DisconnectPeer_FullMethodName          = "/p2p_api.PeerService/DisconnectPeer"
	PeerService_RecordCatchupAttempt_FullMethodName    = "/p2p_api.PeerService/RecordCatchupAttempt"
	PeerService_RecordCatchupSuccess_FullMethodName    = "/p2p_api.PeerService/RecordCatchupSuccess"
	PeerService_RecordCatchupFailure_FullMethodName    = "/p2p_api.PeerService/RecordCatchupFailure"
	PeerService_RecordCatchupMalicious_FullMethodName  = "/p2p_api.PeerService/RecordCatchupMalicious"
	PeerService_UpdateCatchupReputation_FullMethodName = "/p2p_api.PeerService/UpdateCatchupReputation"
	PeerService_UpdateCatchupError_FullMethodName      = "/p2p_api.PeerService/UpdateCatchupError"
	PeerService_GetPeersForCatchup_FullMethodName      = "/p2p_api.PeerService/GetPeersForCatchup"
	PeerService_ReportValidSubtree_FullMethodName      = "/p2p_api.PeerService/ReportValidSubtree"
	PeerService_ReportValidBlock_FullMethodName        = "/p2p_api.PeerService/ReportValidBlock"
	PeerService_IsPeerMalicious_FullMethodName         = "/p2p_api.PeerService/IsPeerMalicious"
	PeerService_IsPeerUnhealthy_FullMethodName         = "/p2p_api.PeerService/IsPeerUnhealthy"
	PeerService_GetPeerRegistry_FullMethodName         = "/p2p_api.PeerService/GetPeerRegistry"
	PeerService_RecordBytesDownloaded_FullMethodName   = "/p2p_api.PeerService/RecordBytesDownloaded"
	PeerService_GetPeer_FullMethodName                 = "/p2p_api.PeerService/GetPeer"
)

// PeerServiceClient is the client API for PeerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Add new service for peer operations
type PeerServiceClient interface {
	GetPeers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetPeersResponse, error)
	BanPeer(ctx context.Context, in *BanPeerRequest, opts ...grpc.CallOption) (*BanPeerResponse, error)
	UnbanPeer(ctx context.Context, in *UnbanPeerRequest, opts ...grpc.CallOption) (*UnbanPeerResponse, error)
	IsBanned(ctx context.Context, in *IsBannedRequest, opts ...grpc.CallOption) (*IsBannedResponse, error)
	ListBanned(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListBannedResponse, error)
	ClearBanned(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClearBannedResponse, error)
	AddBanScore(ctx context.Context, in *AddBanScoreRequest, opts ...grpc.CallOption) (*AddBanScoreResponse, error)
	ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error)
	DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error)
	// Catchup metrics reporting endpoints
	RecordCatchupAttempt(ctx context.Context, in *RecordCatchupAttemptRequest, opts ...grpc.CallOption) (*RecordCatchupAttemptResponse, error)
	RecordCatchupSuccess(ctx context.Context, in *RecordCatchupSuccessRequest, opts ...grpc.CallOption) (*RecordCatchupSuccessResponse, error)
	RecordCatchupFailure(ctx context.Context, in *RecordCatchupFailureRequest, opts ...grpc.CallOption) (*RecordCatchupFailureResponse, error)
	RecordCatchupMalicious(ctx context.Context, in *RecordCatchupMaliciousRequest, opts ...grpc.CallOption) (*RecordCatchupMaliciousResponse, error)
	UpdateCatchupReputation(ctx context.Context, in *UpdateCatchupReputationRequest, opts ...grpc.CallOption) (*UpdateCatchupReputationResponse, error)
	UpdateCatchupError(ctx context.Context, in *UpdateCatchupErrorRequest, opts ...grpc.CallOption) (*UpdateCatchupErrorResponse, error)
	GetPeersForCatchup(ctx context.Context, in *GetPeersForCatchupRequest, opts ...grpc.CallOption) (*GetPeersForCatchupResponse, error)
	// Subtree and block validation reporting
	ReportValidSubtree(ctx context.Context, in *ReportValidSubtreeRequest, opts ...grpc.CallOption) (*ReportValidSubtreeResponse, error)
	ReportValidBlock(ctx context.Context, in *ReportValidBlockRequest, opts ...grpc.CallOption) (*ReportValidBlockResponse, error)
	// Peer status checking
	IsPeerMalicious(ctx context.Context, in *IsPeerMaliciousRequest, opts ...grpc.CallOption) (*IsPeerMaliciousResponse, error)
	IsPeerUnhealthy(ctx context.Context, in *IsPeerUnhealthyRequest, opts ...grpc.CallOption) (*IsPeerUnhealthyResponse, error)
	// Get full peer registry data with all metadata
	GetPeerRegistry(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetPeerRegistryResponse, error)
	// Record bytes downloaded via HTTP from a peer
	RecordBytesDownloaded(ctx context.Context, in *RecordBytesDownloadedRequest, opts ...grpc.CallOption) (*RecordBytesDownloadedResponse, error)
	// Get single peer information by peer ID
	GetPeer(ctx context.Context, in *GetPeerRequest, opts ...grpc.CallOption) (*GetPeerResponse, error)
}

type peerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPeerServiceClient(cc grpc.ClientConnInterface) PeerServiceClient {
	return &peerServiceClient{cc}
}

func (c *peerServiceClient) GetPeers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetPeersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeersResponse)
	err := c.cc.Invoke(ctx, PeerService_GetPeers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) BanPeer(ctx context.Context, in *BanPeerRequest, opts ...grpc.CallOption) (*BanPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BanPeerResponse)
	err := c.cc.Invoke(ctx, PeerService_BanPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) UnbanPeer(ctx context.Context, in *UnbanPeerRequest, opts ...grpc.CallOption) (*UnbanPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnbanPeerResponse)
	err := c.cc.Invoke(ctx, PeerService_UnbanPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) IsBanned(ctx context.Context, in *IsBannedRequest, opts ...grpc.CallOption) (*IsBannedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsBannedResponse)
	err := c.cc.Invoke(ctx, PeerService_IsBanned_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) ListBanned(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListBannedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBannedResponse)
	err := c.cc.Invoke(ctx, PeerService_ListBanned_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) ClearBanned(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ClearBannedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearBannedResponse)
	err := c.cc.Invoke(ctx, PeerService_ClearBanned_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) AddBanScore(ctx context.Context, in *AddBanScoreRequest, opts ...grpc.CallOption) (*AddBanScoreResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddBanScoreResponse)
	err := c.cc.Invoke(ctx, PeerService_AddBanScore_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) ConnectPeer(ctx context.Context, in *ConnectPeerRequest, opts ...grpc.CallOption) (*ConnectPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectPeerResponse)
	err := c.cc.Invoke(ctx, PeerService_ConnectPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) DisconnectPeer(ctx context.Context, in *DisconnectPeerRequest, opts ...grpc.CallOption) (*DisconnectPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectPeerResponse)
	err := c.cc.Invoke(ctx, PeerService_DisconnectPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) RecordCatchupAttempt(ctx context.Context, in *RecordCatchupAttemptRequest, opts ...grpc.CallOption) (*RecordCatchupAttemptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordCatchupAttemptResponse)
	err := c.cc.Invoke(ctx, PeerService_RecordCatchupAttempt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) RecordCatchupSuccess(ctx context.Context, in *RecordCatchupSuccessRequest, opts ...grpc.CallOption) (*RecordCatchupSuccessResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordCatchupSuccessResponse)
	err := c.cc.Invoke(ctx, PeerService_RecordCatchupSuccess_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) RecordCatchupFailure(ctx context.Context, in *RecordCatchupFailureRequest, opts ...grpc.CallOption) (*RecordCatchupFailureResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordCatchupFailureResponse)
	err := c.cc.Invoke(ctx, PeerService_RecordCatchupFailure_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) RecordCatchupMalicious(ctx context.Context, in *RecordCatchupMaliciousRequest, opts ...grpc.CallOption) (*RecordCatchupMaliciousResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordCatchupMaliciousResponse)
	err := c.cc.Invoke(ctx, PeerService_RecordCatchupMalicious_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) UpdateCatchupReputation(ctx context.Context, in *UpdateCatchupReputationRequest, opts ...grpc.CallOption) (*UpdateCatchupReputationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCatchupReputationResponse)
	err := c.cc.Invoke(ctx, PeerService_UpdateCatchupReputation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) UpdateCatchupError(ctx context.Context, in *UpdateCatchupErrorRequest, opts ...grpc.CallOption) (*UpdateCatchupErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCatchupErrorResponse)
	err := c.cc.Invoke(ctx, PeerService_UpdateCatchupError_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) GetPeersForCatchup(ctx context.Context, in *GetPeersForCatchupRequest, opts ...grpc.CallOption) (*GetPeersForCatchupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeersForCatchupResponse)
	err := c.cc.Invoke(ctx, PeerService_GetPeersForCatchup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) ReportValidSubtree(ctx context.Context, in *ReportValidSubtreeRequest, opts ...grpc.CallOption) (*ReportValidSubtreeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportValidSubtreeResponse)
	err := c.cc.Invoke(ctx, PeerService_ReportValidSubtree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) ReportValidBlock(ctx context.Context, in *ReportValidBlockRequest, opts ...grpc.CallOption) (*ReportValidBlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportValidBlockResponse)
	err := c.cc.Invoke(ctx, PeerService_ReportValidBlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) IsPeerMalicious(ctx context.Context, in *IsPeerMaliciousRequest, opts ...grpc.CallOption) (*IsPeerMaliciousResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsPeerMaliciousResponse)
	err := c.cc.Invoke(ctx, PeerService_IsPeerMalicious_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) IsPeerUnhealthy(ctx context.Context, in *IsPeerUnhealthyRequest, opts ...grpc.CallOption) (*IsPeerUnhealthyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsPeerUnhealthyResponse)
	err := c.cc.Invoke(ctx, PeerService_IsPeerUnhealthy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) GetPeerRegistry(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetPeerRegistryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeerRegistryResponse)
	err := c.cc.Invoke(ctx, PeerService_GetPeerRegistry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) RecordBytesDownloaded(ctx context.Context, in *RecordBytesDownloadedRequest, opts ...grpc.CallOption) (*RecordBytesDownloadedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RecordBytesDownloadedResponse)
	err := c.cc.Invoke(ctx, PeerService_RecordBytesDownloaded_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) GetPeer(ctx context.Context, in *GetPeerRequest, opts ...grpc.CallOption) (*GetPeerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeerResponse)
	err := c.cc.Invoke(ctx, PeerService_GetPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PeerServiceServer is the server API for PeerService service.
// All implementations must embed UnimplementedPeerServiceServer
// for forward compatibility.
//
// Add new service for peer operations
type PeerServiceServer interface {
	GetPeers(context.Context, *emptypb.Empty) (*GetPeersResponse, error)
	BanPeer(context.Context, *BanPeerRequest) (*BanPeerResponse, error)
	UnbanPeer(context.Context, *UnbanPeerRequest) (*UnbanPeerResponse, error)
	IsBanned(context.Context, *IsBannedRequest) (*IsBannedResponse, error)
	ListBanned(context.Context, *emptypb.Empty) (*ListBannedResponse, error)
	ClearBanned(context.Context, *emptypb.Empty) (*ClearBannedResponse, error)
	AddBanScore(context.Context, *AddBanScoreRequest) (*AddBanScoreResponse, error)
	ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error)
	DisconnectPeer(context.Context, *DisconnectPeerRequest) (*DisconnectPeerResponse, error)
	// Catchup metrics reporting endpoints
	RecordCatchupAttempt(context.Context, *RecordCatchupAttemptRequest) (*RecordCatchupAttemptResponse, error)
	RecordCatchupSuccess(context.Context, *RecordCatchupSuccessRequest) (*RecordCatchupSuccessResponse, error)
	RecordCatchupFailure(context.Context, *RecordCatchupFailureRequest) (*RecordCatchupFailureResponse, error)
	RecordCatchupMalicious(context.Context, *RecordCatchupMaliciousRequest) (*RecordCatchupMaliciousResponse, error)
	UpdateCatchupReputation(context.Context, *UpdateCatchupReputationRequest) (*UpdateCatchupReputationResponse, error)
	UpdateCatchupError(context.Context, *UpdateCatchupErrorRequest) (*UpdateCatchupErrorResponse, error)
	GetPeersForCatchup(context.Context, *GetPeersForCatchupRequest) (*GetPeersForCatchupResponse, error)
	// Subtree and block validation reporting
	ReportValidSubtree(context.Context, *ReportValidSubtreeRequest) (*ReportValidSubtreeResponse, error)
	ReportValidBlock(context.Context, *ReportValidBlockRequest) (*ReportValidBlockResponse, error)
	// Peer status checking
	IsPeerMalicious(context.Context, *IsPeerMaliciousRequest) (*IsPeerMaliciousResponse, error)
	IsPeerUnhealthy(context.Context, *IsPeerUnhealthyRequest) (*IsPeerUnhealthyResponse, error)
	// Get full peer registry data with all metadata
	GetPeerRegistry(context.Context, *emptypb.Empty) (*GetPeerRegistryResponse, error)
	// Record bytes downloaded via HTTP from a peer
	RecordBytesDownloaded(context.Context, *RecordBytesDownloadedRequest) (*RecordBytesDownloadedResponse, error)
	// Get single peer information by peer ID
	GetPeer(context.Context, *GetPeerRequest) (*GetPeerResponse, error)
	mustEmbedUnimplementedPeerServiceServer()
}

// UnimplementedPeerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPeerServiceServer struct{}

func (UnimplementedPeerServiceServer) GetPeers(context.Context, *emptypb.Empty) (*GetPeersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeers not implemented")
}
func (UnimplementedPeerServiceServer) BanPeer(context.Context, *BanPeerRequest) (*BanPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BanPeer not implemented")
}
func (UnimplementedPeerServiceServer) UnbanPeer(context.Context, *UnbanPeerRequest) (*UnbanPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnbanPeer not implemented")
}
func (UnimplementedPeerServiceServer) IsBanned(context.Context, *IsBannedRequest) (*IsBannedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsBanned not implemented")
}
func (UnimplementedPeerServiceServer) ListBanned(context.Context, *emptypb.Empty) (*ListBannedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBanned not implemented")
}
func (UnimplementedPeerServiceServer) ClearBanned(context.Context, *emptypb.Empty) (*ClearBannedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearBanned not implemented")
}
func (UnimplementedPeerServiceServer) AddBanScore(context.Context, *AddBanScoreRequest) (*AddBanScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddBanScore not implemented")
}
func (UnimplementedPeerServiceServer) ConnectPeer(context.Context, *ConnectPeerRequest) (*ConnectPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectPeer not implemented")
}
func (UnimplementedPeerServiceServer) DisconnectPeer(context.Context, *DisconnectPeerRequest) (*DisconnectPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectPeer not implemented")
}
func (UnimplementedPeerServiceServer) RecordCatchupAttempt(context.Context, *RecordCatchupAttemptRequest) (*RecordCatchupAttemptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordCatchupAttempt not implemented")
}
func (UnimplementedPeerServiceServer) RecordCatchupSuccess(context.Context, *RecordCatchupSuccessRequest) (*RecordCatchupSuccessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordCatchupSuccess not implemented")
}
func (UnimplementedPeerServiceServer) RecordCatchupFailure(context.Context, *RecordCatchupFailureRequest) (*RecordCatchupFailureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordCatchupFailure not implemented")
}
func (UnimplementedPeerServiceServer) RecordCatchupMalicious(context.Context, *RecordCatchupMaliciousRequest) (*RecordCatchupMaliciousResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordCatchupMalicious not implemented")
}
func (UnimplementedPeerServiceServer) UpdateCatchupReputation(context.Context, *UpdateCatchupReputationRequest) (*UpdateCatchupReputationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCatchupReputation not implemented")
}
func (UnimplementedPeerServiceServer) UpdateCatchupError(context.Context, *UpdateCatchupErrorRequest) (*UpdateCatchupErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCatchupError not implemented")
}
func (UnimplementedPeerServiceServer) GetPeersForCatchup(context.Context, *GetPeersForCatchupRequest) (*GetPeersForCatchupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeersForCatchup not implemented")
}
func (UnimplementedPeerServiceServer) ReportValidSubtree(context.Context, *ReportValidSubtreeRequest) (*ReportValidSubtreeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportValidSubtree not implemented")
}
func (UnimplementedPeerServiceServer) ReportValidBlock(context.Context, *ReportValidBlockRequest) (*ReportValidBlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportValidBlock not implemented")
}
func (UnimplementedPeerServiceServer) IsPeerMalicious(context.Context, *IsPeerMaliciousRequest) (*IsPeerMaliciousResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPeerMalicious not implemented")
}
func (UnimplementedPeerServiceServer) IsPeerUnhealthy(context.Context, *IsPeerUnhealthyRequest) (*IsPeerUnhealthyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsPeerUnhealthy not implemented")
}
func (UnimplementedPeerServiceServer) GetPeerRegistry(context.Context, *emptypb.Empty) (*GetPeerRegistryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeerRegistry not implemented")
}
func (UnimplementedPeerServiceServer) RecordBytesDownloaded(context.Context, *RecordBytesDownloadedRequest) (*RecordBytesDownloadedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordBytesDownloaded not implemented")
}
func (UnimplementedPeerServiceServer) GetPeer(context.Context, *GetPeerRequest) (*GetPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPeer not implemented")
}
func (UnimplementedPeerServiceServer) mustEmbedUnimplementedPeerServiceServer() {}
func (UnimplementedPeerServiceServer) testEmbeddedByValue()                     {}

// UnsafePeerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PeerServiceServer will
// result in compilation errors.
type UnsafePeerServiceServer interface {
	mustEmbedUnimplementedPeerServiceServer()
}

func RegisterPeerServiceServer(s grpc.ServiceRegistrar, srv PeerServiceServer) {
	// If the following call pancis, it indicates UnimplementedPeerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PeerService_ServiceDesc, srv)
}

func _PeerService_GetPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetPeers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetPeers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_BanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).BanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_BanPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).BanPeer(ctx, req.(*BanPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_UnbanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbanPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).UnbanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_UnbanPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).UnbanPeer(ctx, req.(*UnbanPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_IsBanned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsBannedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).IsBanned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_IsBanned_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).IsBanned(ctx, req.(*IsBannedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_ListBanned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).ListBanned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_ListBanned_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).ListBanned(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_ClearBanned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).ClearBanned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_ClearBanned_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).ClearBanned(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_AddBanScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddBanScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).AddBanScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_AddBanScore_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).AddBanScore(ctx, req.(*AddBanScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_ConnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).ConnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_ConnectPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).ConnectPeer(ctx, req.(*ConnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_DisconnectPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).DisconnectPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_DisconnectPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).DisconnectPeer(ctx, req.(*DisconnectPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_RecordCatchupAttempt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordCatchupAttemptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).RecordCatchupAttempt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_RecordCatchupAttempt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).RecordCatchupAttempt(ctx, req.(*RecordCatchupAttemptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_RecordCatchupSuccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordCatchupSuccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).RecordCatchupSuccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_RecordCatchupSuccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).RecordCatchupSuccess(ctx, req.(*RecordCatchupSuccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_RecordCatchupFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordCatchupFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).RecordCatchupFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_RecordCatchupFailure_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).RecordCatchupFailure(ctx, req.(*RecordCatchupFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_RecordCatchupMalicious_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordCatchupMaliciousRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).RecordCatchupMalicious(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_RecordCatchupMalicious_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).RecordCatchupMalicious(ctx, req.(*RecordCatchupMaliciousRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_UpdateCatchupReputation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCatchupReputationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).UpdateCatchupReputation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_UpdateCatchupReputation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).UpdateCatchupReputation(ctx, req.(*UpdateCatchupReputationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_UpdateCatchupError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCatchupErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).UpdateCatchupError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_UpdateCatchupError_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).UpdateCatchupError(ctx, req.(*UpdateCatchupErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_GetPeersForCatchup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeersForCatchupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetPeersForCatchup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetPeersForCatchup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetPeersForCatchup(ctx, req.(*GetPeersForCatchupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_ReportValidSubtree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportValidSubtreeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).ReportValidSubtree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_ReportValidSubtree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).ReportValidSubtree(ctx, req.(*ReportValidSubtreeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_ReportValidBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportValidBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).ReportValidBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_ReportValidBlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).ReportValidBlock(ctx, req.(*ReportValidBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_IsPeerMalicious_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsPeerMaliciousRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).IsPeerMalicious(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_IsPeerMalicious_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).IsPeerMalicious(ctx, req.(*IsPeerMaliciousRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_IsPeerUnhealthy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsPeerUnhealthyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).IsPeerUnhealthy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_IsPeerUnhealthy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).IsPeerUnhealthy(ctx, req.(*IsPeerUnhealthyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_GetPeerRegistry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetPeerRegistry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetPeerRegistry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetPeerRegistry(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_RecordBytesDownloaded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordBytesDownloadedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).RecordBytesDownloaded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_RecordBytesDownloaded_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).RecordBytesDownloaded(ctx, req.(*RecordBytesDownloadedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_GetPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetPeer(ctx, req.(*GetPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PeerService_ServiceDesc is the grpc.ServiceDesc for PeerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PeerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "p2p_api.PeerService",
	HandlerType: (*PeerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPeers",
			Handler:    _PeerService_GetPeers_Handler,
		},
		{
			MethodName: "BanPeer",
			Handler:    _PeerService_BanPeer_Handler,
		},
		{
			MethodName: "UnbanPeer",
			Handler:    _PeerService_UnbanPeer_Handler,
		},
		{
			MethodName: "IsBanned",
			Handler:    _PeerService_IsBanned_Handler,
		},
		{
			MethodName: "ListBanned",
			Handler:    _PeerService_ListBanned_Handler,
		},
		{
			MethodName: "ClearBanned",
			Handler:    _PeerService_ClearBanned_Handler,
		},
		{
			MethodName: "AddBanScore",
			Handler:    _PeerService_AddBanScore_Handler,
		},
		{
			MethodName: "ConnectPeer",
			Handler:    _PeerService_ConnectPeer_Handler,
		},
		{
			MethodName: "DisconnectPeer",
			Handler:    _PeerService_DisconnectPeer_Handler,
		},
		{
			MethodName: "RecordCatchupAttempt",
			Handler:    _PeerService_RecordCatchupAttempt_Handler,
		},
		{
			MethodName: "RecordCatchupSuccess",
			Handler:    _PeerService_RecordCatchupSuccess_Handler,
		},
		{
			MethodName: "RecordCatchupFailure",
			Handler:    _PeerService_RecordCatchupFailure_Handler,
		},
		{
			MethodName: "RecordCatchupMalicious",
			Handler:    _PeerService_RecordCatchupMalicious_Handler,
		},
		{
			MethodName: "UpdateCatchupReputation",
			Handler:    _PeerService_UpdateCatchupReputation_Handler,
		},
		{
			MethodName: "UpdateCatchupError",
			Handler:    _PeerService_UpdateCatchupError_Handler,
		},
		{
			MethodName: "GetPeersForCatchup",
			Handler:    _PeerService_GetPeersForCatchup_Handler,
		},
		{
			MethodName: "ReportValidSubtree",
			Handler:    _PeerService_ReportValidSubtree_Handler,
		},
		{
			MethodName: "ReportValidBlock",
			Handler:    _PeerService_ReportValidBlock_Handler,
		},
		{
			MethodName: "IsPeerMalicious",
			Handler:    _PeerService_IsPeerMalicious_Handler,
		},
		{
			MethodName: "IsPeerUnhealthy",
			Handler:    _PeerService_IsPeerUnhealthy_Handler,
		},
		{
			MethodName: "GetPeerRegistry",
			Handler:    _PeerService_GetPeerRegistry_Handler,
		},
		{
			MethodName: "RecordBytesDownloaded",
			Handler:    _PeerService_RecordBytesDownloaded_Handler,
		},
		{
			MethodName: "GetPeer",
			Handler:    _PeerService_GetPeer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "services/p2p/p2p_api/p2p_api.proto",
}
